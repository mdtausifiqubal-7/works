<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Camera Tool</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple loader animation */
        #loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .thumbnail-container {
            position: relative;
            display: inline-block;
        }
        .thumbnail-container .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: red;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-4">

    <div class="w-full max-w-lg">
        <h1 class="text-3xl font-bold text-center text-cyan-400 mb-6">AI Camera Tool</h1>

        <!-- Camera and Image Display Area -->
        <div class="bg-gray-800 rounded-lg shadow-xl overflow-hidden mb-4 relative aspect-[3/4]">
            <video id="video-feed" class="w-full h-full object-cover" autoplay playsinline></video>
            <canvas id="capture-canvas" class="hidden"></canvas>
            <img id="current-captured-image-preview" class="w-full h-full object-cover hidden" alt="Captured photo">
        </div>

        <div class="flex flex-wrap justify-center items-center gap-3 mb-4">
            <button id="start-camera" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg flex items-center space-x-2 transition duration-200 shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></svg>
                <span>Add Photo</span>
            </button>
            
            <button id="take-picture" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg flex items-center space-x-2 transition duration-200 shadow-lg hidden">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle></svg>
                <span>Take Picture</span>
            </button>

            <button id="toggle-flash" class="bg-gray-700 hover:bg-gray-600 text-white font-bold p-3 rounded-lg flex items-center justify-center transition duration-200 shadow-lg hidden" title="Toggle Flashlight">
                <svg id="flash-off-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap-off"><path d="M12.41 6.75 13 2l-2.43 2.92"/><path d="M18.57 12.91 21 10h-5.34"/><path d="M8 8v-2l4 6h3l-4-6V4c0-1.1-.9-2-2-2S6 2.9 6 4v2"/><path d="M2 2l20 20"/><path d="M7 10h.78l-1.87 2.34L7.4 18.08l2.07-2.6-1.5-1.85h.36L13 22l-1.39-1.68h-.01L6 12h-4l3-9h2.17"/></svg>
                <svg id="flash-on-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap hidden"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
            </button>
        </div>

        <!-- Image Gallery for Multiple Photos -->
        <div id="image-gallery" class="flex flex-wrap justify-center gap-3 mb-6 p-3 bg-gray-800 rounded-lg min-h-[80px] border border-gray-700">
            <p class="text-gray-500 text-sm italic">No photos added yet.</p>
        </div>

        <!-- AI Prompt Section -->
        <div id="ai-section" class="w-full hidden">
            <label for="ai-prompt" class="block text-sm font-medium text-gray-300 mb-2">Your Prompt:</label>
            <textarea id="ai-prompt" rows="6" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-500">
You are analyzing a series of images, each containing a form. For each image, extract the form data for each person found and return it as a structured JSON array. The overall response should be a JSON array, where each element corresponds to one image, and contains an array of person objects for that image.

Each person object in the inner array should have the following keys: "Student", "Father", "Mother", "DOB", "Class", "Mobile", "Address". If a field is blank, not found, or unclear, use null for its value.
Only return the raw JSON array (an array of arrays) and no other text.
Example for two images, each with one person:
[
  [
    { "Student": "John Doe", "Father": "Richard Doe", "Mother": "Jane Doe", "DOB": "01-01-2000", "Class": "X", "Mobile": "1234567890", "Address": "123 Main St" }
  ],
  [
    { "Student": "Alice Smith", "Father": "Robert Smith", "Mother": "Emily Smith", "DOB": "05-10-1999", "Class": "IX", "Mobile": "0987654321", "Address": "456 Oak Ave" }
  ]
]
</textarea>
            
            <button id="analyze-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center w-full mt-4 transition duration-200 shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3c.8 0 1.5.7 1.5 1.5v3c0 .8-.7 1.5-1.5 1.5s-1.5-.7-1.5-1.5v-3c0-.8.7 1.5 1.5-1.5zM6.4 7.4c.6.6 1.5.6 2.1 0l2.1-2.1c.6-.6.6-1.5 0-2.1s-1.5-.6-2.1 0L6.4 5.3c-.6.6-.6 1.5 0 2.1zM17.6 7.4c.6.6 1.5.6 2.1 0l2.1-2.1c.6-.6.6-1.5 0-2.1s-1.5-.6-2.1 0l-2.1 2.1c-.6.6-.6 1.5 0 2.1zM12 21c.8 0 1.5-.7 1.5-1.5v-3c0 .8-.7 1.5-1.5 1.5s-1.5.7-1.5 1.5v3c0 .8.7 1.5 1.5 1.5zM6.4 16.6c.6.6 1.5.6 2.1 0l2.1-2.1c.6-.6.6-1.5 0-2.1s-1.5-.6-2.1 0l-2.1 2.1c-.6.6-.6 1.5 0 2.1zM17.6 16.6c.6.6 1.5.6 2.1 0l2.1-2.1c.6-.6.6-1.5 0-2.1s-1.5-.6-2.1 0l-2.1 2.1c-.6.6-.6 1.5 0 2.1z"></path></svg>
                <span class="ml-2">Analyze with AI</span>
            </button>
        </div>

        <!-- Result Section -->
        <div class="w-full mt-6">
            <h3 class="text-lg font-semibold text-gray-200 mb-2">AI Analysis:</h3>
            <div id="loader" class="hidden mx-auto"></div>
            <!-- Custom error message box -->
            <div id="error-box" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4" role="alert">
                <strong class="font-bold">Error:</strong>
                <span class="block sm:inline" id="error-message"></span>
            </div>
            <div id="result-box" class="w-full min-h-[100px] bg-gray-800 rounded-lg p-4 whitespace-pre-wrap text-gray-300 shadow-inner">Waiting for analysis...</div>
            
            <!-- New Download Button -->
            <button id="download-csv" class="hidden bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center w-full mt-4 transition duration-200 shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                <span class="ml-2">Download as CSV (Excel)</span>
            </button>
        </div>
    </div>

    <!-- 
    =========================================================================
    SECURE SCRIPT SECTION
    This script is now secure. It does NOT contain an API key.
    It calls /api/analyze, which is your secure backend function.
    =========================================================================
    -->
    <script>
        // --- DOM Elements ---
        const videoFeed = document.getElementById('video-feed');
        const captureCanvas = document.getElementById('capture-canvas');
        const currentCapturedImagePreview = document.getElementById('current-captured-image-preview');
        const startCameraButton = document.getElementById('start-camera');
        const takePictureButton = document.getElementById('take-picture');
        const aiSection = document.getElementById('ai-section');
        const aiPrompt = document.getElementById('ai-prompt');
        const analyzeButton = document.getElementById('analyze-button');
        const loader = document.getElementById('loader');
        const resultBox = document.getElementById('result-box');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');
        const downloadCsvButton = document.getElementById('download-csv');
        const imageGallery = document.getElementById('image-gallery');
        const toggleFlashButton = document.getElementById('toggle-flash');
        const flashOnIcon = document.getElementById('flash-on-icon');
        const flashOffIcon = document.getElementById('flash-off-icon');

        // --- State ---
        let stream = null;
        let capturedImages = []; // Array to store { id: uuid, base64: string } objects
        let lastAnalysisData = null; // To hold the JSON data from AI
        let isFlashOn = false; // New state for flash
        let hasFlash = false; // New state to track flash capability

        // --- Helper Functions ---

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
            console.error(message);
        }

        function clearError() {
            errorBox.classList.add('hidden');
        }

        function stopCameraStream() {
            if (stream) {
                stream.getTracks().forEach(track => {
                    if (track.getCapabilities().torch) {
                        try {
                            track.applyConstraints({ advanced: [{ torch: false }] });
                        } catch (e) {
                            console.warn("Could not turn off torch on track stop:", e);
                        }
                    }
                    track.stop();
                });
                stream = null;
            }
            toggleFlashButton.classList.add('hidden');
            toggleFlashButton.classList.replace('bg-yellow-500', 'bg-gray-700');
            toggleFlashButton.classList.replace('hover:bg-yellow-600', 'hover:bg-gray-600');
            isFlashOn = false;
            hasFlash = false;
            flashOnIcon.classList.add('hidden');
            flashOffIcon.classList.remove('hidden');
        }

        // --- UI Update Functions ---

        function renderImageGallery() {
            imageGallery.innerHTML = ''; // Clear existing
            if (capturedImages.length === 0) {
                imageGallery.innerHTML = '<p class="text-gray-500 text-sm italic">No photos added yet.</p>';
                aiSection.classList.add('hidden'); // Hide AI section if no images
            } else {
                capturedImages.forEach(img => {
                    const thumbContainer = document.createElement('div');
                    thumbContainer.classList.add('thumbnail-container');
                    
                    const imgElement = document.createElement('img');
                    imgElement.src = `data:image/png;base64,${img.base64}`;
                    imgElement.classList.add('w-20', 'h-20', 'object-cover', 'rounded-md', 'border', 'border-gray-600', 'shadow');
                    thumbContainer.appendChild(imgElement);

                    const removeBtn = document.createElement('span');
                    removeBtn.classList.add('remove-btn');
                    removeBtn.textContent = 'x';
                    removeBtn.title = 'Remove photo';
                    removeBtn.addEventListener('click', () => removeImage(img.id));
                    thumbContainer.appendChild(removeBtn);

                    imageGallery.appendChild(thumbContainer);
                });
                aiSection.classList.remove('hidden'); // Show AI section if images exist
            }
            updateAnalyzeButtonState(); // Update analyze button state
        }

        function updateAnalyzeButtonState() {
            analyzeButton.disabled = capturedImages.length === 0;
            if (capturedImages.length === 0) {
                downloadCsvButton.classList.add('hidden');
                resultBox.textContent = "Waiting for analysis...";
            }
        }

        // --- Core Functions ---

        async function checkFlashCapability() {
            if (!stream) return;
            try {
                const track = stream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();
                
                if (capabilities.torch) {
                    hasFlash = true;
                    toggleFlashButton.classList.remove('hidden');
                    isFlashOn = false;
                    flashOnIcon.classList.add('hidden');
                    flashOffIcon.classList.remove('hidden');
                    toggleFlashButton.classList.replace('bg-yellow-500', 'bg-gray-700');
                    toggleFlashButton.classList.replace('hover:bg-yellow-600', 'hover:bg-gray-600');
                    
                    const settings = track.getSettings();
                    if (settings.torch) {
                        isFlashOn = true;
                        flashOnIcon.classList.remove('hidden');
                        flashOffIcon.classList.add('hidden');
                        toggleFlashButton.classList.replace('bg-gray-700', 'bg-yellow-500');
                        toggleFlashButton.classList.replace('hover:bg-gray-600', 'hover:bg-yellow-600');
                    } else {
                         await track.applyConstraints({ advanced: [{ torch: false }] });
                    }
                } else {
                    hasFlash = false;
                    toggleFlashButton.classList.add('hidden');
                }
            } catch (err) {
                console.warn("Could not check flash capability:", err);
                hasFlash = false;
                toggleFlashButton.classList.add('hidden');
            }
        }

        async function startCamera() {
            clearError();
            stopCameraStream();
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        aspectRatio: { ideal: 3/4 }
                    },
                    audio: false
                });
                videoFeed.srcObject = stream;
                videoFeed.classList.remove('hidden');
                currentCapturedImagePreview.classList.add('hidden');
                
                videoFeed.onloadedmetadata = () => {
                    checkFlashCapability();
                };
                
                startCameraButton.classList.add('hidden');
                takePictureButton.classList.remove('hidden');
                
            } catch (err) {
                console.error("Error accessing camera:", err);
                showError("Could not access camera. Please check permissions. " + err.message);
            }
        }

        function takePicture() {
            clearError();
            if (!stream) {
                showError("Camera is not active. Please click 'Add Photo' first.");
                return;
            }

            const context = captureCanvas.getContext('2d');
            captureCanvas.width = videoFeed.videoWidth;
            captureCanvas.height = videoFeed.videoHeight;
            context.drawImage(videoFeed, 0, 0, captureCanvas.width, captureCanvas.height);
            
            const imageDataUrl = captureCanvas.toDataURL('image/png');
            const base64Data = imageDataUrl.split(',')[1];
            
            capturedImages.push({
                id: generateUUID(),
                base64: base64Data
            });
            
            currentCapturedImagePreview.src = imageDataUrl;
            videoFeed.classList.add('hidden');
            currentCapturedImagePreview.classList.remove('hidden');

            stopCameraStream();

            takePictureButton.classList.add('hidden');
            startCameraButton.classList.remove('hidden');
            startCameraButton.querySelector('span').textContent = 'Add Another Photo';
            
            renderImageGallery();
            resultBox.textContent = "Waiting for analysis...";
            downloadCsvButton.classList.add('hidden');
            lastAnalysisData = null;
        }

        async function toggleFlash() {
            if (!stream || !hasFlash) return;
            
            try {
                const track = stream.getVideoTracks()[0];
                isFlashOn = !isFlashOn;
                await track.applyConstraints({ advanced: [{ torch: isFlashOn }] });

                if (isFlashOn) {
                    flashOnIcon.classList.remove('hidden');
                    flashOffIcon.classList.add('hidden');
                    toggleFlashButton.classList.replace('bg-gray-700', 'bg-yellow-500');
                    toggleFlashButton.classList.replace('hover:bg-gray-600', 'hover:bg-yellow-600');
                } else {
                    flashOnIcon.classList.add('hidden');
                    flashOffIcon.classList.remove('hidden');
                    toggleFlashButton.classList.replace('bg-yellow-500', 'bg-gray-700');
                    toggleFlashButton.classList.replace('hover:bg-yellow-600', 'hover:bg-gray-600');
                }
            } catch (err) {
                console.error("Error toggling flash:", err);
                showError("Could not control flashlight. " + err.message);
                isFlashOn = !isFlashOn;
            }
        }

        function removeImage(idToRemove) {
            capturedImages = capturedImages.filter(img => img.id !== idToRemove);
            renderImageGallery();
            resultBox.textContent = "Waiting for analysis...";
            downloadCsvButton.classList.add('hidden');
            lastAnalysisData = null;
            clearError();
        }

        /**
         * Sends all captured images and prompt to OUR SECURE API.
         */
        async function analyzeImage() {
            if (capturedImages.length === 0) {
                showError("Please take at least one picture first.");
                return;
            }
            
            clearError();
            loader.classList.remove('hidden');
            resultBox.textContent = "Analyzing " + capturedImages.length + " image(s)...";
            analyzeButton.disabled = true;
            downloadCsvButton.classList.add('hidden');
            lastAnalysisData = null;

            const prompt = aiPrompt.value;

            const contentParts = [{ text: prompt }];
            capturedImages.forEach(img => {
                contentParts.push({
                    inlineData: {
                        mimeType: "image/png",
                        data: img.base64
                    }
                });
            });

            // This is the payload we will send to OUR serverless function
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: contentParts
                    }
                ],
            };

            // =================================================================
            // THIS IS THE KEY CHANGE!
            // We now call our OWN API endpoint, /api/analyze, not Google's.
            // =================================================================
            try {
                // 1. Call your new Vercel function
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload) // Send the same payload
                });

                // 2. Get the data from your function's response
                const result = await response.json();

                // 3. Handle errors from your function
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to analyze');
                }

                // 4. The rest of your logic is the same!
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (text) {
                    try {
                        const parsedData = JSON.parse(text);
                        lastAnalysisData = parsedData.flat(); 
                        resultBox.textContent = JSON.stringify(parsedData, null, 2);
                        downloadCsvButton.classList.remove('hidden');
                    } catch (parseError) {
                        console.error("JSON parse error:", parseError);
                        resultBox.textContent = text;
                        showError("AI did not return valid JSON, but here is the raw text. You may need to adjust the prompt or image quality.");
                        lastAnalysisData = null;
                    }
                } else {
                    console.error("Invalid API response structure:", result);
                    showError("Could not parse AI response. See console for details.");
                    resultBox.textContent = JSON.stringify(result, null, 2);
                }

            } catch (err) {
                console.error("Error analyzing image(s):", err);
                showError("Failed to analyze image(s). " + err.message);
                resultBox.textContent = "Analysis failed.";
            } finally {
                loader.classList.add('hidden');
                analyzeButton.disabled = false;
            }
        }

        /**
         * Converts JSON data to CSV and triggers a download.
         */
        function downloadCSV() {
            if (!lastAnalysisData || !Array.isArray(lastAnalysisData) || lastAnalysisData.length === 0) {
                showError("No valid data to export. Analyze photos first.");
                return;
            }

            try {
                const headers = Array.from(new Set(lastAnalysisData.flatMap(Object.keys)));
                let csvContent = headers.map(h => `"${h.replace(/"/g, '""')}"`).join(',') + '\n';

                lastAnalysisData.forEach(row => {
                    const values = headers.map(header => {
                        let value = row[header];
                        if (value === null || value === undefined) {
                            value = "";
                        }
                        let stringValue = String(value);
                        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                            stringValue = '"' + stringValue.replace(/"/g, '""') + '"';
                        }
                        return stringValue;
                    });
                    csvContent += values.join(',') + '\n';
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'ai_extracted_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

            } catch (err) {
                console.error("Error creating CSV:", err);
                showError("Could not create CSV file. " + err.message);
            }
        }

        // --- Initial Setup and Event Listeners ---
        startCameraButton.addEventListener('click', startCamera);
        takePictureButton.addEventListener('click', takePicture);
        analyzeButton.addEventListener('click', analyzeImage);
        downloadCsvButton.addEventListener('click', downloadCSV);
        toggleFlashButton.addEventListener('click', toggleFlash);

        renderImageGallery();
        updateAnalyzeButtonSgittate();

        window.addEventListener('beforeunload', stopCameraStream);

    </script>
</body>
</html>
